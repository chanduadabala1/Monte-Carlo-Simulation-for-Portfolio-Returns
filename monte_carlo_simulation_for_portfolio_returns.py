# -*- coding: utf-8 -*-
"""monte-carlo-simulation-for-portfolio-returns.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/chanduadabala1/ef7959561f38ffa7f321e6ddc97fc9ba/monte-carlo-simulation-for-portfolio-returns.ipynb
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

# --- 1. User Inputs ---
print("--- Indian Market Portfolio Simulator ---")
investment = 100000
simulations = 1000
years = 1

# Standardize to .NS for better reliability
tickers = ['RELIANCE.NS', 'INFY.NS', 'TCS.NS', 'GOLDBEES.NS']
weights = np.array([0.40, 0.20, 0.20, 0.20])

# --- 2. Data Fetching ---
print(f"Fetching data for: {', '.join(tickers)}...")

# Download data and fill missing values (holidays)
data = yf.download(tickers, period="3y")['Close']
data = data.ffill().dropna()

if data.empty:
    raise ValueError("Error: No data fetched. Check your internet or ticker symbols.")

# Ensure weights sum to 1
weights = weights / np.sum(weights)

# Calculate Returns & Statistics
log_returns = np.log(1 + data.pct_change()).dropna()

mean_returns = log_returns.mean().to_numpy()
std_devs = log_returns.std().to_numpy()
corr_matrix = log_returns.corr().to_numpy()
L = np.linalg.cholesky(corr_matrix)

# --- 3. Simulation Engine ---
days = 252 * years
portfolio_sims = np.zeros((days, simulations))
current_prices = data.iloc[-1].to_numpy()

# Check for NaNs in starting price
if np.isnan(current_prices).any():
    print("Warning: Last row of data contains NaNs. Using second-to-last row.")
    current_prices = data.iloc[-2].to_numpy()

print(f"Running {simulations} simulations...")

for m in range(simulations):
    # Generate correlated random shocks
    Z = np.dot(L, np.random.normal(0, 1, (len(tickers), days))).T
    drift = mean_returns - 0.5 * std_devs**2

    # Calculate price paths for this simulation
    paths = np.zeros((days, len(tickers)))
    paths[0] = current_prices

    for t in range(1, days):
        paths[t] = paths[t-1] * np.exp(drift + std_devs * Z[t])

    # Calculate Portfolio Value
    shares = (investment * weights) / paths[0]
    portfolio_sims[:, m] = np.dot(paths, shares)

# --- 4. Metrics ---
final_vals = portfolio_sims[-1, :]
final_vals = final_vals[np.isfinite(final_vals)] # Safety cleanup

if len(final_vals) == 0:
    raise ValueError("Simulation failed: All outcomes were NaN.")

expected_value = np.mean(final_vals)
var_95 = np.percentile(final_vals, 5)

print("\n--- RESULTS ---")
print(f"Expected Final Value: ₹{expected_value:,.2f}")
print(f"Value at Risk (95%): ₹{var_95:,.2f}")

# --- 5. Visualizations (UPDATED) ---

# Create a figure with 2 subplots (1 row, 2 columns)
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

# Plot 1: Distributed Simulation Paths (The Spaghetti Plot)
# We plot the first 100 paths so the graph isn't too crowded
ax1.plot(portfolio_sims[:, :100], alpha=0.4, linewidth=1)
ax1.set_title(f"Monte Carlo Simulation ({simulations} Paths)")
ax1.set_xlabel("Trading Days")
ax1.set_ylabel("Portfolio Value (₹)")
ax1.grid(True, alpha=0.3)

# Plot 2: Distribution of Final Outcomes (Histogram)
ax2.hist(final_vals, bins=50, color='orange', edgecolor='black', alpha=0.7)
ax2.axvline(var_95, color='red', linestyle='--', linewidth=2, label=f'95% VaR: ₹{var_95:,.0f}')
ax2.axvline(expected_value, color='green', linestyle='-', linewidth=2, label=f'Mean: ₹{expected_value:,.0f}')
ax2.set_title("Distribution of Final Portfolio Values")
ax2.set_xlabel("Final Value (₹)")
ax2.set_ylabel("Frequency")
ax2.legend()
ax2.grid(True, alpha=0.3)



plt.tight_layout()
plt.show()

